// PDF Generator for Reports - uses jsPDF (dynamic import)

export interface ReportData {
  companyName: string;
  reportTitle: string;
  dateRange: string;
  summary: { label: string; value: string; color?: string }[];
  records: { columns: string[]; rows: string[][] };
  generatedBy: string;
  generatedAt: string;
}

export async function generateReportPDF(data: ReportData): Promise<Blob> {
  const { jsPDF } = await import('jspdf');
  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });

  let yPos = 20;
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 15;
  const contentWidth = pageWidth - margin * 2;

  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(data.companyName, pageWidth / 2, yPos, { align: 'center' });
  yPos += 10;

  doc.setFontSize(14);
  doc.text(data.reportTitle, pageWidth / 2, yPos, { align: 'center' });
  yPos += 7;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text(data.dateRange, pageWidth / 2, yPos, { align: 'center' });
  yPos += 12;

  doc.setDrawColor(200, 200, 200);
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += 10;

  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Summary', margin, yPos);
  yPos += 8;

  data.summary.forEach((item) => {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(80, 80, 80);
    doc.text(item.label + ':', margin, yPos);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text(item.value, margin + 40, yPos);
    yPos += 6;
  });

  yPos += 8;
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += 10;

  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('Records', margin, yPos);
  yPos += 8;

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, yPos - 5, contentWidth, 8, 'F');
  doc.setFontSize(9);
  const colWidth = contentWidth / data.records.columns.length;
  data.records.columns.forEach((col, index) => {
    doc.text(col, margin + colWidth * index + 2, yPos);
  });
  yPos += 10;

  doc.setFont('helvetica', 'normal');
  doc.setFontSize(8);
  data.records.rows.forEach((row, rowIndex) => {
    if (yPos > 270) {
      doc.addPage();
      yPos = 20;
      doc.setFillColor(240, 240, 240);
      doc.rect(margin, yPos - 5, contentWidth, 8, 'F');
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(9);
      data.records.columns.forEach((col, index) => {
        doc.text(col, margin + colWidth * index + 2, yPos);
      });
      yPos += 10;
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
    }
    if (rowIndex % 2 === 0) {
      doc.setFillColor(250, 250, 250);
      doc.rect(margin, yPos - 4, contentWidth, 7, 'F');
    }
    row.forEach((cell, index) => {
      const text = cell.length > 20 ? cell.substring(0, 17) + '...' : cell;
      doc.text(text, margin + colWidth * index + 2, yPos);
    });
    yPos += 7;
  });

  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(150, 150, 150);
    doc.text(`Generated by: ${data.generatedBy}`, margin, 285);
    doc.text(`Date: ${data.generatedAt}`, margin, 290);
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, 290);
  }

  return doc.output('blob');
}

export function downloadPDF(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}

export function printPDF(blob: Blob) {
  const url = URL.createObjectURL(blob);
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.src = url;
  document.body.appendChild(iframe);
  iframe.onload = () => {
    iframe.contentWindow?.print();
    setTimeout(() => {
      document.body.removeChild(iframe);
      URL.revokeObjectURL(url);
    }, 1000);
  };
}

export async function sharePDF(blob: Blob, filename: string, title: string): Promise<boolean> {
  const file = new File([blob], filename, { type: 'application/pdf' });
  if (navigator.share && navigator.canShare?.({ files: [file] })) {
    try {
      await navigator.share({ title, text: `Sharing ${title}`, files: [file] });
      return true;
    } catch {
      downloadPDF(blob, filename);
      return false;
    }
  }
  downloadPDF(blob, filename);
  return false;
}
