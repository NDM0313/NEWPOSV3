// PDF Generator utility for Reports
// Uses jsPDF library for PDF generation

export interface ReportData {
  companyName: string;
  reportTitle: string;
  dateRange: string;
  summary: {
    label: string;
    value: string;
    color?: string;
  }[];
  records: {
    columns: string[];
    rows: string[][];
  };
  generatedBy: string;
  generatedAt: string;
}

export async function generateReportPDF(data: ReportData): Promise<Blob> {
  // Dynamically import jsPDF to reduce bundle size
  const { jsPDF } = await import('jspdf');
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  let yPos = 20;
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 15;
  const contentWidth = pageWidth - (margin * 2);

  // Company Name (Header)
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(data.companyName, pageWidth / 2, yPos, { align: 'center' });
  yPos += 10;

  // Report Title
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(data.reportTitle, pageWidth / 2, yPos, { align: 'center' });
  yPos += 7;

  // Date Range
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text(data.dateRange, pageWidth / 2, yPos, { align: 'center' });
  yPos += 12;

  // Divider Line
  doc.setDrawColor(200, 200, 200);
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += 10;

  // Summary Section
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Summary', margin, yPos);
  yPos += 8;

  // Summary Cards
  data.summary.forEach((item) => {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(80, 80, 80);
    doc.text(item.label + ':', margin, yPos);
    
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text(item.value, margin + 40, yPos);
    yPos += 6;
  });

  yPos += 8;

  // Divider Line
  doc.setDrawColor(200, 200, 200);
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += 10;

  // Records Section
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Records', margin, yPos);
  yPos += 8;

  // Table Header
  doc.setFillColor(240, 240, 240);
  doc.rect(margin, yPos - 5, contentWidth, 8, 'F');
  
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  
  const colWidth = contentWidth / data.records.columns.length;
  data.records.columns.forEach((col, index) => {
    doc.text(col, margin + (colWidth * index) + 2, yPos);
  });
  yPos += 10;

  // Table Rows
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(8);
  
  data.records.rows.forEach((row, rowIndex) => {
    // Check if we need a new page
    if (yPos > 270) {
      doc.addPage();
      yPos = 20;
      
      // Re-print header on new page
      doc.setFillColor(240, 240, 240);
      doc.rect(margin, yPos - 5, contentWidth, 8, 'F');
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(9);
      data.records.columns.forEach((col, index) => {
        doc.text(col, margin + (colWidth * index) + 2, yPos);
      });
      yPos += 10;
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
    }

    // Alternating row colors
    if (rowIndex % 2 === 0) {
      doc.setFillColor(250, 250, 250);
      doc.rect(margin, yPos - 4, contentWidth, 7, 'F');
    }

    row.forEach((cell, index) => {
      const text = cell.length > 20 ? cell.substring(0, 17) + '...' : cell;
      doc.text(text, margin + (colWidth * index) + 2, yPos);
    });
    yPos += 7;
  });

  // Footer
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(150, 150, 150);
    
    // Generated info
    doc.text(`Generated by: ${data.generatedBy}`, margin, 285);
    doc.text(`Date: ${data.generatedAt}`, margin, 290);
    
    // Page number
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, 290);
  }

  return doc.output('blob');
}

export function downloadPDF(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}

export function printPDF(blob: Blob) {
  const url = URL.createObjectURL(blob);
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.src = url;
  document.body.appendChild(iframe);
  
  iframe.onload = () => {
    iframe.contentWindow?.print();
    setTimeout(() => {
      document.body.removeChild(iframe);
      URL.revokeObjectURL(url);
    }, 1000);
  };
}

export async function sharePDF(blob: Blob, filename: string, title: string) {
  const file = new File([blob], filename, { type: 'application/pdf' });
  
  if (navigator.share && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({
        title: title,
        text: `Sharing ${title}`,
        files: [file]
      });
      return true;
    } catch (error) {
      // User cancelled or error occurred
      console.error('Share failed:', error);
      return false;
    }
  } else {
    // Fallback: Download the file
    downloadPDF(blob, filename);
    return false;
  }
}
